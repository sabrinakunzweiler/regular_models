r"""
Resolution graphs of surface singularities
==========================================

By a *surface* we mean an excellent, integral and normal scheme of
dimension `2`. Let `X` be a surface and `x\in X` a closed point. We assume that
`X` is not regular in `x` (we say that `x\in X` is a *surface singularity*).

It is well known that there exists a *resolution* of `X` at `x`, i.e.\ a proper
and birational morphism

.. MATH::

            \pi: X' \to X,

where `X'` is a surface which is regular in a neighborhood of `E:=\pi^{-1}(x)`.
We call `E` the *exceptional fiber* of the resolution `\pi`.

Let `E_1,\ldots,E_n` denote the (reduced) irreducible components of `E`. Each
`E_i` is a reduced curve over the residue field `k=k(x)`, and it is a prime
Cartier divisor on `X'`. There is an intersection pairing between Cartier
divisors on `X'` and Cartier divisors with support on `E`. In particular, we
obtain an *intersection matrix*

.. MATH::

            M := (E_i.E_j)_{i,j}.

By definition, `M` is a square matrix with integer coefficients, and that
`E_j.E_j\geq 0` for `i\neq j'. It is well known that, moreover, `M` is symmetric
and negative definite. Note that this forces `E_i^2:=E_i.E_i < 0`, for all `i`.

This situation motivates the following definition:


**Definition:** An (abstract) *resolution graph* is a tripel `(E,M,g)`, where
`E=\{E_1,\ldots,E_n\}` is a finite set (which we index, for convenience, by
the integers `i=1,\ldots,n`), `M` is an `n`-by-`n` symmetric and negative
definite matrix with integer coefficients and `g=(g_1,\ldots,g_n)` is a list
of `n` nonnegative integers `g_i\geq 0`. We will denote by `E_i.E_j` the entry
of `M` at position `(i,j)`, and we assume that `E_i.E_j\geq 0` for `i\neq j`.
The integer `g_i` is called the *arithmetic genus* of the component `E_i`.

By a *cycle* on `E` we mean an element `Z=\sum_i a_i E_i` of the free abelian
group generated by the set `E`. There is an obvious partial ordering between
cycles: `Z\leq Z'` if `Z=\sum_i a_iE_i`, `Z'=\sum_i a_i'E_i` and `a_i\leq a_i'`
for all `i`. A cycle `Z` is called *positive* if `Z>0`. The intersection matrix
`M` induces a bilinear, integer-valued and negative definite pairing

.. MATH::

            (Z, Z') \mapsto Z.Z'

such that `E_i.E_j` is the entry of `M` at position `(i,j)`.


.. TODO::

- implement -1-components, contractions and minimal models
- implement the resolution graphs of type `(p,r,s)` from Obus-Wewers
- develop and implement the concept of *tame cyclic covers* of resolution graphs

"""

from sage.all import ZZ, matrix, SageObject, Graph, copy


class ResolutionGraph(SageObject):
    r""" Return the resolution graph corresponding to an intersection matrix

    INPUT:

    - ``M`` -- a symmetric and negative matrix with integer coefficients
    - ``genera`` -- a list of nonegative integers, or ``None``
      (default: ``None``). The length must match the dimension of ``M``

    OUTPUT: the resolution graph `E` corresponding to `M`. The vertices `E_i`
    (called the *components* of the resolution graph) are labeled by the
    integers `i=0,\ldots,n-1`, where `n` is the dimension of `M`. The `i`th
    entry `g_i` of ``genera`` is the genus of the component `E_i`.

    If ``genera`` is ``None``, then we assume `g_i=0` for all `i`.

    """

    def __init__(self, M, genera=None):

        m, n = M.dimensions()
        assert n == m, "intersection matrix has to be a square matrix"
        self._number_of_components = n
        assert M.is_symmetric(), "intersection matrix has to be symmetric"
        # check that diagonal entries are negative and the rest are nonnegative
        check = True
        for i in range(n):
            for j in range(n):
                if i == j and M[i, i] >= 0:
                    check = False
                if i != j and M[i, j] < 0:
                    check = False
        assert check, "this is not an intersection matrix"
        # check that M is negative definite
        assert all([(-1)**(n - i) * M.submatrix(i, i).determinant() > 0 for i in
                    range(n)]), "intersection matrix must be negative definite"
        self._intersection_matrix = M
        if genera is None:
            self._genera = [0 for i in range(n)]
        else:
            assert all([g >= 0 for g in genera]), \
                "genera have to be nonnegative"
            assert len(genera) == n, "list of genera has to match matrix"
            self._genera = genera

    def __repr__(self):

        return "resolution graph with {} components".format(self.number_of_components())

    def components(self):
        r""" Return the list of components.

        At the moment, the components are identified with the integers
        `0,\ldots,n-1`, where `n` is the number of components.

        """
        return range(self._number_of_components)

    def number_of_components(self):
        r""" Return the number of components of this resolution graph.

        """
        return self._number_of_components

    def intersection(self, i, j):
        r""" Return the intersection number `E_i.E_j`.

        INPUT:

        - ``i``, ``j`` -- integers in ``range(n)``, where `n` is the number
          of components

        """
        return self._intersection_matrix[i, j]

    def self_intersection(self, i):

        return self._intersection_matrix[i, i]

    def is_connected(self):

        return self.graph().is_connected()

    def graph(self):
        r""" Return the weighted graph underlying this resolution graph.

        Output: An undirected, weighted Sage Graph.

        The vertices are labeled by the integers `0,\ldots,n-1`. The weight
        of an edge is the intersection number of the components corresponding
        to the vertices connected by the edge.

        """
        if not hasattr(self, "_graph"):
            M = copy(self._intersection_matrix)
            for i in self.components():
                M[i, i] = 0
            self._graph = Graph(M, format='weighted_adjacency_matrix')
        return self._graph

    def show_graph(self):
        r""" Plot the underlying graph of this resolution graph.

        """
        self.graph().show(edge_labels=True)

    def labeled_graph(self):
        r""" Return the labeled graph underlying this resolution graph.

        OUTPUT: An undirected, weighted Sage Graph.

        The vertices are labeled by pairs `(i,-a_i)`, where `-a_i=E_i.E_i`
        is the self intersection number of the component `E_i`. The weight
        of an edge is the intersection number of the components corresponding
        to the vertices connected by the edge.

        """
        G = self.graph()
        a = [self.self_intersection(i) for i in self.components()]
        edges = G.edges()
        new_edges = []
        for i, j, w in edges:
            new_edges.append(((i, a[i]), (j, a[j]), w))
        return Graph(new_edges)

    def show_labeled_graph(self):
        r""" Plot the underlying labeled graph of this resolution graph.

        """
        self.labeled_graph().show(edge_labels=True, vertex_size=1200)

    def genus_of_component(self, i):
        r""" Return the genus of the component `E_i`.

        INPUT:

        - ``i`` -- an integer in ``range(n)``, where `n` is the number of
          components of this resolution graph.

        OUTPUT: the arithmetic genus of the component `E_i`.

        """
        return self._genera[i]

    def is_tree(self):
        r""" Return ``True`` if the underlying graph is a tree.

        """
        return self.graph().is_tree()

    def cycle(self, a):
        r""" Return the cycle corresponding to a list of multiplicities.

        INPUT:

        - ``a`` -- a list of integers; the length of ``a`` must match the
          number of components

        OUTPUT: the cycle `Z=\sum_i a_iE_i`.

        """
        return CycleOnResolutionGraph(self, a)

    def fundamental_cycle(self):
        r""" Return the fundamental cycle of this resolution graph.

        The fundamental cycle is defined as the (unique) minimal good cycle `Z`.
        Here a cycle `Z` is called *good* if it is positive, and
        `Z.E_i\leq 0` for all `i`.

        The fundamental cycle can be computed with the 'Laufer algorithm', see ..

        """
        if hasattr(self, "_fundamental_cycle"):
            return self._fundamental_cycle
        n = self.number_of_components()
        # initialize Z:=E_0
        Z = self.cycle([1] + [0 for i in range(n - 1)])
        while True:
            positive_components = Z.bad_components()
            if len(positive_components) == 0:
                self._fundamental_cycle = Z
                return Z
            else:
                Z.add_component(positive_components[0])

    def genus_of_fundamental_cycle(self):
        r""" Return the arithmetic genus of the fundamental cycle.

        """
        return self.fundamental_cycle().genus()

    def is_rational(self):
        r""" Return ``True`` if this resolution graph is rational.

        This is the case if and only if the arithmetic genus of the fundamental
        cycle is zero. See ...

        """
        return self.genus_of_fundamental_cycle() == 0


#  some special resolution graphs
#  ------------------------------


def modified_continued_fraction(n, r):
    r""" Return the modified continued fraction expansion of `n/r`.

    INPUT:

    - ``n``, ``r`` -- positive integers such that `n>r`

    OUPUT: a list `[a_0,\ldots,a_s]` of integers `a_i\geq 2`.

    The `a_i` are determined inductively by the following conditions:

    - 'a_0' is the least integer such that `a_0 \geq n/r`
    - if `n/r` is an integer then `s=0`. Otherwise, `[a_1,\ldots,a_s]`
      is the modified continued fraction expansion of `1/(a_0-n/r)`.

    """
    assert n > r and r > 0, "We must have n>r>0."
    ret = []
    alpha = n / r
    a = alpha.ceil()
    while a > alpha:
        ret.append(a)
        alpha = 1 / (a - alpha)
        a = alpha.ceil()
    ret.append(a)
    return ret


def resolution_graph_of_cyclic_quotient_singularity(n, r):
    r"""  Return the resolution graph of the tame cyclic quotient singularity
        of type `(n,r)`.

    INPUT:

    - ``n``, ``r`` -- positive integers such that `n>r`

    OUTPUT: the resolution graph of a tame cyclic quotient singularity
    of type `(n,r)`. See ..

    Let `(a_0,\ldots,a_s)` be the modified continued fraction expansion of `n/r`.
    Then the resolution graph is a chain of components `E_0,\ldots,E_s`, where
    `E_i` is smooth of genus zero and has selfintersection `-a_i`.

    """
    a = modified_continued_fraction(n, r)
    n = len(a)
    M = matrix(ZZ, n, n)
    for i in range(n):
        M[i, i] = - a[i]
        if i > 0:
            M[i, i - 1] = 1
            M[i - 1, i] = 1
    return ResolutionGraph(M)


#
#


class CycleOnResolutionGraph(SageObject):
    r""" Return the cycle on the resolution graph, with given multiplities.

    INPUT:

    - ``E`` -- a resolution graph
    - ``a`` -- a list of integers, or ``None`` (default: ``None``);
      the length of `a` has to match the number of components of `E`

    OUTPUT: the cycle `Z=\sum_i a_iE_i`. If ``a``=``None`` then we set `Z:=0`.

    """
    def __init__(self, E, a=None):
        self._resolution_graph = E
        n = E.number_of_components()
        if a is None:
            # Z is initialized as the zero cycle
            a = [ZZ.zero() for i in range(n)]
        else:
            assert len(a) == n, "length of a must match number of components"
        self._multiplicities = a

    def __repr__(self):

        return 'cycle on resolution graph with multiplicities {}'.format(self._multiplicities)

    def resolution_graph(self):
        r""" Return the resolution graph underlying this cycle.

        """
        return self._resolution_graph

    def multiplicity(self, i):
        r""" Return the muliplicity of the component `E_i` in this cycle.

        """
        return self._multiplicities[i]

    def is_positive(self):
        r""" Return ``True`` if this cycle is positive.

        """
        return all([m >= 0 for m in self._multiplicities]) and \
            not all([m == 0 for m in self._multiplicities])

    def intersection_with_component(self, i):
        r""" Return the intersection number `Z.E_i`.

        """
        E = self.resolution_graph()
        n = E.number_of_components()
        return sum([self.multiplicity(j) * E.intersection(i, j)
                    for j in range(n)])

    def intersection_with_cycle(self, Z):
        r""" Return the intersection number of this cycle with the cycle `Z`.

        """
        E = self.resolution_graph()
        n = E.number_of_components()
        return sum([self.intersection_with_component(i) * Z.multiplicity(i)
                    for i in range(n)])

    def self_intersection(self):
        r""" Return the selfintersection number of this cycle.

        """
        return self.intersection_with_cycle(self)

    def intersection_with_canonical_divisor(self):
        r""" Return the intersection number of this cycle with the canonical divisor.

        Here the canonical divisor `K` is considered as a linear form on the
        group of cycles on the given resolution graph `E`. It is uniquely
        determined by the condition (the *adjunction formula*):

        .. MATH::

                E_i.K = 2g_i - 2 - E_i^2.

        Here `g_i` is the arithmetic genus of the component `E_i`.

        """
        Z = self
        E = Z.resolution_graph()
        return sum([Z.multiplicity(i)
            * (2 * E.genus_of_component(i) - 2 - E.self_intersection(i))
                   for i in E.components()])

    def bad_components(self):
        r""" Return the list of components which are bad with respect to this cycle.

        OUTPUT: the list of integers `i` such that `E_i` is bad with
        to this cycle `Z`.

        Here a component `E_i` is called *bad* with respect to `Z` if

        .. MATH::

                    Z.E_i > 0.

        """
        E = self.resolution_graph()
        return [i for i in E.components()
                if self.intersection_with_component(i) > 0]

    def is_good(self):
        r""" Return ``True`` if this cycle is good, i.e.\ if it is positive
        ad has no bad components.

        """
        return self.is_positive() and len(self.bad_components()) == 0

    def add_component(self, i):
        r""" Replace this cycle `Z` with `Z+E_i`.

        """
        self._multiplicities[i] = self._multiplicities[i] + 1

    def genus(self):
        r""" Return the arithmetic genus of this cycle.

        Here the *arithmetic genus* of a cycle `Z` is defined as the
        (nonnegative) integer

        .. MATH::

                p(Z) := (Z^2 + Z.K)/2 + 1.

        """
        Z = self
        assert Z.is_positive(), "Z has to be positiv"
        return (Z.self_intersection() + Z.intersection_with_canonical_divisor()
                ) / 2 + 1
