def lci(xi):
    r""" Realize the component corresponding to xi as a local complete intersection.

        INPUT:

        - ``xi`` -- a point of type II on the Berkovich line

        OUTPUT:
        - ``F`` -- a polynomial in U and T
        - ``u`` -- a polyomial in x
        - ``t`` -- a polyomial in x
        such that a Zariski neighborhood of xi is isomorphic to O_K[u,t]= O_K[U,T]/(F(U,T)).

        """
    
    #realize the component with generic point `xi` as a local complete intersection
    #use Lemma 5.2
    v = xi.pseudovaluation_on_polynomial_ring()
    K = v.phi().base_ring()
    x = v.phi().variables()[0]
    u = v.uniformizer()
    if u in K:
        k = v(v.phi())
        u = v.phi()/v.uniformizer()^(k-1) # otherwise in this case p would always be chosen as a uniformizer and one gets u-p as defining equation.
    t = v.lift(v.residue_ring().gen())
    B.<U,T,x> = K[]
    I = B.ideal(B(u)-U,B(t)-T)
    return [I.elimination_ideal([x]).gens()[0],u,t]

def ord_dx(xi):
    r"""
    Returns the order of the rational section `dx` on the component with generic point `xi`.

    INPUT:
    -  ``xi`` -- a point of type II on the Berkovich line

    OUTPUT:
    - the order of the rational section `dx` on the component with generic point `xi`

    """""
    v = xi.pseudovaluation_on_polynomial_ring()
    #realize a Zariski neighborhood U of the generic point xi as a local complete intersection
    #use Lemma 5.2
    [F,u,t] = lci(xi)
    #canoncial sheaf on U is generated by 'du/F_t', where 'F_t' is the derivative of 'F' with respect to `t`.
    #So the order of 'dx = du/u_x' is given by v(F_t) - v(u_x)
    u_x = u.derivative()
    R = F.parent()
    U,T,x = R.gens()
    F_t = F.derivative(T)
    return v(R(F_t)(u,t,x)) - v(u_x)


def canonical_sheaf_global_sections(YK, v_K):
    r"""
    Returns the global sections of the canonical sheaf of a regular model of the superelliptic curve YK.

    INPUT:

    -  ``YK`` - a superelliptic curve defined over some field `K`
    -  ``v_K`` - a discrete valuation on `K`
    
    OUTPUT:
    -  An O_K lattice representing the global sections of the canonical a regular model of the superelliptic curve `YK`. The differential forms are         viewed as elements in the function `K(YK)` under the embedding `\omega \mapsto \omega y^{n-1}/dx`

    """""
    K = YK.base() # v_K should be a discrete valuation on K
    [f,n] = superelliptic_decomposition(YK.defining_polynomial())
    X = minimal_rnc_model(f, v_K)
    F0 = X.function_field()
    f = F0(f)
    R.<y> = F0[] #use same variables as in defining equation of YK!
    F.<y> = F0.extension(y^n - f)

    B = [F(b) for b in differential_basis_baker(YK.defining_polynomial())]
    M_K = RRSpace(v_K, F, B)
    m=[]
    i=0
    for VC in X.vertical_components():
        xi = VC.generic_point()
        v = xi.pseudovaluation_on_polynomial_ring()
        if not v(v.phi()) == 0:
            i+=1
            v0 = F0.valuation(v)
            w0 = v0.extensions(F)[0]
            M_K.add_valuation(w0, "w{0}".format(i))
            #mv = order of dx on component with generic point xi + ramification index of the cover -1 - (n-1)*w(y)
            e = w0.value_group().index(v0.value_group());
            mv = ord_dx(xi)-w0(y)*(n-1)+ e-1;
            m.append(("w{0}".format(i),-mv))
    return M_K.RR_lattice(m)

# ---------------------------------------------------------------------------

#                          Superelliptic Curves



def SuperellipticCurve(f,n, names = ["x","y"]):
    r"""
    Returns the superelliptic curve `y^n = f`, for a
    univariate polynomial `f` and an integer `n`.

    INPUT:

    -  ``f`` - univariate polynomial of degree `\geq 3`

    -  ``n`` - integer greater than 1.

    -  ``names``  (default: ``["x","y"]``) - names for the
       coordinate functions
    """""
    S = PolynomialRing(f.base_ring(), names)
    x,y = S.gens()
    F = y**n-f(x)
    return Curve(F)

def superelliptic_decomposition(G):
    r""" return a polynomial `f`and an integer `n` such that `G = y^n -f(x)`

    INPUT:

    - ``G`` -- a polynomial defining a superelliptuc curve over a field `K`

    OUTPUT:

    - ``f``
    - ``n``
    """
    K = G.base_ring()
    (x,y) = G.variables()

    superelliptic = False
    if G.coefficient({y:G.degree(y)}) in K and all([G.coefficient({y:i})==0 for i in range(1,G.degree(y))]):
        superelliptic = True
    elif G.coefficient({x:G.degree(x)}) in K and all([G.coefficient({x:i})==0 for i in range(1,G.degree(x))]):
        G = G(y,x)
        superelliptic = True
    assert superelliptic, "The equation G does not define a smooth superelliptic curve (or not implemented yet)"
    assert G.coefficient({y:0}).is_squarefree(), "The superelliptic curve is not smooth."
    R.<x> = K[]
    return [R(G.coefficient({y:0})),G.degree(y)]

def lci(xi):
    r""" Realize the component corresponding to xi as a local complete intersection.

        INPUT:

        - ``xi`` -- a point of type II on the Berkovich line

        OUTPUT:
        - ``F`` -- a polynomial in U and T
        - ``u`` -- a polyomial in x
        - ``t`` -- a polyomial in x
        such that a Zariski neighborhood of xi is isomorphic to O_K[u,t]= O_K[U,T]/(F(U,T)).

        """
    
    #realize the component with generic point `xi` as a local complete intersection
    #use Lemma 5.2
    v = xi.pseudovaluation_on_polynomial_ring()
    K = v.phi().base_ring()
    x = v.phi().variables()[0]
    u = v.uniformizer()
    if u in K:
        k = v(v.phi())
        u = v.phi()/v.uniformizer()^(k-1) # otherwise in this case p would always be chosen as a uniformizer and one gets u-p as defining equation.
    t = v.lift(v.residue_ring().gen())
    B.<U,T,x> = K[]
    I = B.ideal(B(u)-U,B(t)-T)
    return [I.elimination_ideal([x]).gens()[0],u,t]

def ord_dx(xi):
    r"""
    Returns the order of the rational section `dx` on the component with generic point `xi`.

    INPUT:
    -  ``xi`` -- a point of type II on the Berkovich line

    OUTPUT:
    - the order of the rational section `dx` on the component with generic point `xi`

    """""
    v = xi.pseudovaluation_on_polynomial_ring()
    #realize a Zariski neighborhood U of the generic point xi as a local complete intersection
    #use Lemma 5.2
    [F,u,t] = lci(xi)
    #canoncial sheaf on U is generated by 'du/F_t', where 'F_t' is the derivative of 'F' with respect to `t`.
    #So the order of 'dx = du/u_x' is given by v(F_t) - v(u_x)
    u_x = u.derivative()
    R = F.parent()
    U,T,x = R.gens()
    F_t = F.derivative(T)
    return v(R(F_t)(u,t,x)) - v(u_x)


def canonical_sheaf_global_sections(YK, v_K):
    r"""
    Returns the global sections of the canonical sheaf of a regular model of the superelliptic curve YK.

    INPUT:

    -  ``YK`` - a superelliptic curve defined over some field `K`
    -  ``v_K`` - a discrete valuation on `K`
    
    OUTPUT:
    -  An O_K lattice representing the global sections of the canonical a regular model of the superelliptic curve `YK`. The differential forms are         viewed as elements in the function `K(YK)` under the embedding `\omega \mapsto \omega y^{n-1}/dx`

    """""
    K = YK.base() # v_K should be a discrete valuation on K
    [f,n] = superelliptic_decomposition(YK.defining_polynomial())
    X = minimal_rnc_model(f, v_K)
    F0 = X.function_field()
    f = F0(f)
    R.<y> = F0[] #use same variables as in defining equation of YK!
    F.<y> = F0.extension(y^n - f)

    B = [F(b) for b in differential_basis_baker(YK.defining_polynomial())]
    M_K = RRSpace(v_K, F, B)
    m=[]
    i=0
    for VC in X.vertical_components():
        xi = VC.generic_point()
        v = xi.pseudovaluation_on_polynomial_ring()
        if not v(v.phi()) == 0:
            i+=1
            v0 = F0.valuation(v)
            w0 = v0.extensions(F)[0]
            M_K.add_valuation(w0, "w{0}".format(i))
            #mv = order of dx on component with generic point xi + ramification index of the cover -1 - (n-1)*w(y)
            e = w0.value_group().index(v0.value_group());
            mv = ord_dx(xi)-w0(y)*(n-1)+ e-1;
            m.append(("w{0}".format(i),-mv))
    return M_K.RR_lattice(m)

# ---------------------------------------------------------------------------

#                          Superelliptic Curves



def SuperellipticCurve(f,n, names = ["x","y"]):
    r"""
    Returns the superelliptic curve `y^n = f`, for a
    univariate polynomial `f` and an integer `n`.

    INPUT:

    -  ``f`` - univariate polynomial of degree `\geq 3`

    -  ``n`` - integer greater than 1.

    -  ``names``  (default: ``["x","y"]``) - names for the
       coordinate functions
    """""
    S = PolynomialRing(f.base_ring(), names)
    x,y = S.gens()
    F = y**n-f(x)
    return Curve(F)

def superelliptic_decomposition(G):
    r""" return a polynomial `f`and an integer `n` such that `G = y^n -f(x)`

    INPUT:

    - ``G`` -- a polynomial defining a superelliptuc curve over a field `K`

    OUTPUT:

    - ``f``
    - ``n``
    """
    K = G.base_ring()
    (x,y) = G.variables()

    superelliptic = False
    if G.coefficient({y:G.degree(y)}) in K and all([G.coefficient({y:i})==0 for i in range(1,G.degree(y))]):
        superelliptic = True
    elif G.coefficient({x:G.degree(x)}) in K and all([G.coefficient({x:i})==0 for i in range(1,G.degree(x))]):
        G = G(y,x)
        superelliptic = True
    assert superelliptic, "The equation G does not define a smooth superelliptic curve (or not implemented yet)"
    assert G.coefficient({y:0}).is_squarefree(), "The superelliptic curve is not smooth."
    R.<x> = K[]
    return [R(G.coefficient({y:0})),G.degree(y)]