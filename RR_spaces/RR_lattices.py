r"""
Riemann-Roch Lattices
=====================

Let `K` be a field equipped with a discrete valuation `v_K` and let `R` denote
the valuation ring of `v_K`. Let us also fix a field extension `F/K`. Although
this is not necessarily the case, one should think of `F` as the function field
of a smooth projective curve over `K`.

Let `M_K\subset F` be a finitely generated `K`-vector subspace of dimension `n`.
Then for any extension `v` of `v_K` to a discrete valuation on `F`, we obtain an
`R`-submodule of `V`,

.. MATH::

    M_v := \{ f \in M_K \mid v(f) \geq 0 \}.

It is easy to see that `M_v` if a *full lattice*, i.e.\ a free `R`-submodule of
`M_K` of rank `n`. More generally, if `V=\{v_1,\ldots,v_r\}` is a finite set
of valuations as above, then

.. MATH::

  M_V := \bigcap_{v\in V} M_v

is a lattice. We call `M_V` a *Riemann-Roch lattice*.

We define a class ``RRSpace`` whose objects represent a triple `(v_K, F/K, M_K)`
as above. With the available methods it is possible to compute Riemann-Roch
lattices `M_V`.

"""

from sage.all import SageObject


class RRSpace(SageObject):
    r""" Return the Riemann-Roch space defined by the input.

    INPUT:

    - ``v_K`` -- a discrete valuation on a field `K`
    - ``F`` -- a field extension of `K`
    - ``gens`` -- a nonempty list of elements of `F`

    OUTPUT: the object represented by `(v_K, F, M_K)`, where `M_K\subset F`
    is the `K`-subspace generated by ``gens``. Its functionality
    includes:

    - computing the Riemann-Roch lattice `M_V` for a finite set `V` of discrete
      valutions on `F` extending `v_K`
    - for `V_1\subset V_2`, compute the index `(M_{V_1}:M_{V_2})`

    etc.

    """

    def __init__(self, v_K, F, gens):
        from function_spaces import basis_of_function_space
        self._v_K = v_K
        self._F = F
        self._rational_basis = basis_of_function_space(F, gens)
        self._valuations = {}
        self._reduced_basis = {}

    def __repr__(self):
        return "the Riemann-Roch space with basis {}".format(self.rational_basis())

    def base_field(self):
        return self._v_K.domain()

    def base_valuation(self):
        return self._v_K

    def function_field(self):
        return self._F

    def rational_basis(self):
        r""" Return a basis for this Riemann-Roch space.
        """
        if hasattr(self, "_rational_basis"):
            return self._rational_basis

    def valuations(self):
        return self._valuations

    def add_valuation(self, v, key=None):
        r""" Add a valuation to the database, and return the key.

        INPUT:

        - ``v`` -- a discrete valuation on the function field `F`
        - ``key`` -- a string, or number, or .. (default=None)

        OUTPUT: the key for `v` in the database.

        The valuation `v` is added to the database of valuations, and its key is
        returned. It is expected that `v` is an extension of `v_K`, and that it
        has not been added before; but this is not checked.

        If ``key`` is given, it is used as the key. Otherwise, the key will be
        the index of `v`` in the database.
        """
        if not key:
            key = len(self._valuations)
        if key in self._valuations.keys():
            try:
                key = key + 1
            except ValueError:
                print "this key is already in use"
        self._valuations[key] = v

    def reduced_basis(self, val_key):
        r""" Return a reduced basis with respect to one valuation.

        INPUT:

        - ``val_key`` -- a key for a registered valuations

        OUTPUT:

        a basis `(f_1,..,f_r)` of this Riemann_Roch space which is reduced with
        respect to `v`, the valuation corresponding to ``val_key``.

        Reducedness means that for every linear combination of the basis

        .. MATH::

            f = a_1f_1 + \ldot + a_rf_r

        we have

        .. MATH::

            v(f) = \min_i v(a_if_i).

        """
        if val_key in self._reduced_basis:
            return self._reduced_basis[val_key]
        else:
            K = self.base_field()
            basis = self.rational_basis()
            v = self.valuations()[val_key]
            reduced_basis = make_reduced_basis(K, basis, v)
            self._reduced_basis[val_key] = reduced_basis
            return reduced_basis

    def simple_RR_lattice(self, val_key, m):
        r""" Return the simple RR lattice.

        INPUT:

        - ``val_key`` -- a key for a registered valuations
        - ``m`` -- an integer

        OUTPUT:

        The lattice `M_{v,m}` inside the Riemann-Roch space `M_K\subset F`
        defined by the inequality

        .. MATH::

            v(f) \geq m,

        (where `v` is the valuation on the function field `F` corresponding to
        ``val_key``.

        """
        pass

    def RR_lattice(self, key_list):
        pass


# ----------------------------------------------------------------------------

#                    auxiliary functions


def make_reduced_basis(K, B, v):
    r""" Return a reduced basis.

    INPUT:

    - ``K`` -- a field
    - ``B`` -- a list of `K`-linearly independent elements `f_i` of a field
      extension `F/K`
    - ``v`` -- a discrete valuation on `F`

    It is expected that the restriction `v_K:=v|_K` is nontirvial, that
    `F/K` is a function field in one variable, and that the
    residue field `k(v)` of `v` is also a function field over the residue field
    `k` of `v_K`.

    OUTPUT:

    A new basis `B_1` of the `K`-span of `B`, which is reduced with respect to
    `v`.

    """
    v_K = v.restriction(K)
    B_red = [B[0]]
    for i in range(1, len(B)):
        g = B[i]
        a = make_reduced(v_K, g, B_red, v)
        h = g + sum([a[j]*B[j] for j in range(i)])
        B_red.append(h)
    return B_red


def make_reduced(v_K, g, B, v):
    r""" Return the reduction of an element with respect to a reduced basis.

    INPUT:

    - ``v_K`` -- a discrete valuation on a field `K`
    - ``g`` -- a nonzero element of a finled extension `F/K`
    - ``B`` -- a list of `K`-linearly independent elements of `F`
    - ``v`` -- a discrete valuation on `v`, extending `v_K`

    It is assumed that `B` is reduced with respect to `v`, and that `g` does
    not lie in the `K`-span of `B`.

    OUTPUT:

    Write `B = [f_1,\ldots,f_r]`. Then the output is a list `[a_1,\ldots,a_r]`
    of elements of `K` such that `v(h)` is maximal, with

    .. MATH::

        h := g + \sum_i a_i f_i.

    """
    from function_spaces import FunctionSpace
    K = v_K.domain()
    pi = v_K.uniformizer()
    # we want to normalize v_K
    v_K = v_K/v_K(pi)
    k = v_K.residue_field()
    k_v = v.residue_field()
    h = g
    a = [K.zero() for i in range(len(B))]
    e_B = [v(f) for f in B]
    while True:
        e_h = v(h)
        h0 = v.element_with_valuation(e_h)
        hb = v.reduce(h/h0)
        Bb = [v.reduce(B[i]*h0**(-1)*pi**((e_h-e_B[i]).ceil())) for i in range(len(B))]
        Mb = FunctionSpace(k, k_v, Bb)
        is_in_Mb, cb = Mb.is_in(hb)
        if is_in_Mb:
            c = [v_K.lift(cb[i]) for i in range(len(cb))]
            for i in range(len(a)):
                a[i] -= c[i]*pi**((e_h-e_B[i]).ceil())
            h_new = g + sum([a[i]*B[i] for i in range(len(B))])

            # this is only for debugging:
            if v(h_new) <= e_h:
                print "B = ", B
                print "e_B = ", e_B
                print "h = ", h
                print "e_h = ", e_h
                print "h0 = ", h0
                print "hb = ", hb
                print "Bb = ", Bb
                print "cb = ", cb
                print "c = ", c
                print "a = ", a
                print "h_new = ", h_new
                return None

            h = h_new
            assert v(h) > e_h, "something is wrong!"
        else:
            return a
