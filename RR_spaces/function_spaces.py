r"""
Function spaces
===============

By a *function space* we mean a finite dimensional `K`-subspace `V\subset F`,
where `F/K` is a function field.

We define a class ``FunctionSpace`` which realizes this concept. You can create
a function space by giving a list of generators. Then a basis of the span is
computed. One can test whether a given function lies in this span, and express
this function as linear combination of the basis.

This is a basic piece of infrastructure for working with Riemann-Roch spaces
on curves.


AUTHORS:

- Stefan Wewers (2019): initial version


EXAMPLES::

    sage: import regular_models.RR_spaces.function_spaces
    sage: from regular_models.RR_spaces.function_spaces import FunctionSpace

We define a subspace of the function field of a superelliptic curve::

    sage: from mclf import *
    sage: R.<x> = QQ[]
    sage: Y = SuperellipticCurve(x^4 - 1, 3); Y
    superelliptic curve y^3 = x^4 - 1 over Rational Field
    sage: F = Y.function_field()
    sage: x = F.base_field().gen()
    sage: y = F.gen()
    sage: V = FunctionSpace(QQ, F, [x*y, 2*x^2 + y, x^3 + y]); V
    function space of dimension 3 inside Function field in y defined by y^3 - x^4 + 1

We can test whether an element in the function field lies in this space.::

    sage: V.is_in(x^2*y - 3)
    False

We can also express an element of V as a linear combination of the basis::

    sage: V.vector(2*x^2 - x^3 + 2*x*y)
    (2, 1, -1)

"""


# *****************************************************************************
#       Copyright (C) 2019 Stefan Wewers <stefan.wewers@uni-ulm.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# *****************************************************************************


from sage.all import SageObject


class FunctionSpace(SageObject):
    r""" Return the function space with given generator.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a function field over `K`
    - ``gens`` -- a list of elements of `F`

    OUTPUT:

    the `K`-vector subspace of `F` generated by ``gens``.

    EXAMPLES::

        sage: from regular_models.RR_spaces.function_spaces import FunctionSpace
        sage: K = GF(2)
        sage: L.<a> = K.extension(2)
        sage: F.<x> = FunctionField(L)
        sage: V = FunctionSpace(K, F, [a/(x+1), x^2+1, (x+a)/x]); V
        function space of dimension 3 inside Rational function field in x over Finite Field in a of size 2^2

    """

    def __init__(self, K, F, gens):
        assert F.has_coerce_map_from(K), "K must be a subfield of F"
        gens = [F(f) for f in gens]
        self._base_field = K
        self._function_field = F
        self._gens = gens
        A, _ = matrix_representation(K, F, gens)
        indices = A.pivot_rows()
        self._basis = [gens[i] for i in indices]

    def __repr__(self):
        return "function space of dimension {} inside {}".format(self.dimension(),
                                                                 self.function_field())

    def base_field(self):
        return self._base_field

    def function_field(self):
        return self._function_field

    def generators(self):
        r""" Return the list of the original generators of this function space.

        """
        return self._gens

    def basis(self):
        return self._basis

    def dimension(self):
        return len(self.basis())

    def vector(self, f):
        r""" Return vector representations of a list of functions.

        INPUT:

        - ``f`` -- an elelement of the function field `F`

        OUTPUT:

        a vector in `K^d` representing `f` as a linear combination of the
        standard basis of this function space.

        If no such representation exists (i.e.\ if `f` does not lie in this
        function space) then ``None`` is returned.

        """
        from sage.modules.free_module_element import vector
        is_in, v = self.is_in(f, coefficients=True)
        if is_in:
            return vector(self.base_field(), v)
        else:
            return None

    def is_in(self, f, coefficients=False, generators=False):
        r""" Return whether f lies in this function space.

        INPUT:

        - ``f`` -- an element of this function space
        - ``coefficients`` -- a boolean (default=``True``)
        - ``generators`` -- a boolean (default=`False`)

        OUTPUT:

        ``True`` if `f` lies in this function space, ``False`` otherwise.
        If ``coefficients`` is true, then we also get the list of coefficients
        presenting `f` as a `K`-linear combination of the standard basis
        (or ``None`` if `f` does not lie in our function space).
        If ``generators`` is ``True`` then we use the original list of
        generators instead of the standard basis.

        """
        K = self.base_field()
        F = self.function_field()
        assert f in F, "f must lie in the function field F"
        if generators:
            f_list = self._gens + [f]
        else:
            f_list = self._basis + [f]
        n = len(f_list) - 1
        relations = relation_space(K, F, f_list).basis()
        for i in range(len(relations)):
            relation = relations[i]
            if not relation[n].is_zero():
                # f lies in the function space
                c = relation[n]
                if coefficients:
                    return True, [-a/c for a in relation[:n]]
                else:
                    return True
        if coefficients:
            return False, None
        else:
            return False


# ----------------------------------------------------------------------------

#                          auxiliary functions


def basis_of_function_space(K, F, v):
    r""" Return a sublist which is a basis.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a finitely generated field extension of `K`
    - ``v`` -- a vector over `F`, or a list of elements of `F`

    OUTPUT:

    a basis of the `K`-subspace of `F` generated by the entries of `v`.

    EXAMPLES:

    ::

        sage: from regular_models.RR_spaces.function_spaces import basis_of_function_space
        sage: F.<x> = FunctionField(QQ)
        sage: basis_of_function_space(QQ, F, [x, 1/x, (x^2+1)/x, (x+1)/x^2])
        [x, 1/x, (x + 1)/x^2]
        sage: R.<y> = F[]
        sage: F1.<y> = F.extension(y^2-x^3-1)
        sage: basis_of_function_space(QQ, F1, [x*y, (x/(x^3 + 1))*y, ((x^4 + 2*x)/(x^3 + 1))*y])
        [x*y, (x/(x^3 + 1))*y]

    """
    A, _ = matrix_representation(K, F, v)
    indices = A.pivot_rows()
    return [v[i] for i in indices]


def relation_space(K, F, f_list):
    r""" Return the space of relations between a given list of elements of F.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a finitely generated field extension of `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT: suppose ``f_list`` is `[f_1,\ldots,f_n]`. Then we return the
    subspace of `K^n` consisting of all linear relations between the `f_i`.

    EXAMPLES::

        sage: from regular_models.RR_spaces.function_spaces import relation_space
        sage: F.<x> = FunctionField(QQ)
        sage: relation_space(QQ, F, [x+1, x-1, x+1])
        Vector space of degree 3 and dimension 1 over Rational Field
        Basis matrix:
        [ 1  0 -1]

    """
    A, _ = matrix_representation(K, F, f_list)
    return A.kernel()


def is_finite_simple_extension(K, L):
    r""" Check whether `L` is a finite simple field extension of `K`.

    """
    return K == L.base_ring()


def vector_for_finite_extension(K, F, c):
    r""" Return the vector representation of an element of a finite simple extension.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a finite simple field extension of `K`
    - ``c`` -- an element of `F`

    OUTPUT: a vector `(c_i)` over `K` such that

    .. MATH::

            c = \sum_i c_i a^i,

    where `a` is the standard generator of `F/K`.

    This is an ugly hack, but it seems necessary because, depending on the type
    of field, there seem to be different conventions for how to acces such a
    vector representation.

    EXAMPLES::

        sage: from regular_models.RR_spaces.function_spaces import vector_for_finite_extension
        sage: K = GF(2)
        sage: F.<a> = K.extension(3)
        sage: vector_for_finite_extension(K, F, a^2)
        (0, 0, 1)
        sage: K = QQ
        sage: R.<x> = K[]
        sage: F.<a> = K.extension(x^3 - 2)
        sage: vector_for_finite_extension(K, F, a^2)
        (0, 0, 1)
        sage: K.<x> = FunctionField(QQ)
        sage: R.<y> = K[]
        sage: F.<y> = K.extension(y^3 - x^2 -1)
        sage: vector_for_finite_extension(K, F, y^2)
        (0, 0, 1)

    """
    a = F.gen()
    c = F(c)
    assert K == F.base_ring()
    if F.is_finite():
        v = c.matrix().column(0)
    elif hasattr(c, 'vector'):
        v = c.vector()
    else:
        v = c.matrix().row(0)
    assert c == sum(v[i]*a**i for i in range(len(v)))
    return v


def is_rational_function_field(K, F):
    r""" Check whether `F` is a rational function field over `K`.

    """
    return F == F.base_ring() and K == F.constant_base_field()


def is_composite(K, F):
    r""" Check whether `F` is a composite field extension of `K`.

    """
    return (F.has_coerce_map_from(K)
            and not (K == F.base_ring() and K == F.constant_base_field()))


def intermediate_field(K, F):
    r""" Return a proper intermediate field.

    """
    F0 = F.base_ring()
    if not F0 == F:
        return F0
    else:
        return F.constant_base_field()


def matrix_representation(K, F, v):
    r""" Return a matrix representation of a given list of elements.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a finitely generated field extension of `K`
    - ``v`` -- a vector over `F`, or a list with entries in `F`

    OUTPUT: a pair `(A, w)`, where `A` is a matrix with entries in `K` and
    `w` is a vector over `F`, such that the entries of `w` are `K`-linearly
    independent and

    .. MATH::

             v = w*A^t.

    It follows that all the entries of `v` are contained in the `K`-span of the
    entries of `w`, and that the left kernel of `A` is the space of `K`-relations
    between the entries of `v`.

    EXAMPLES::

        sage: from regular_models.RR_spaces.function_spaces import matrix_representation
        sage: K = GF(2)
        sage: F1.<a> = K.extension(3)
        sage: v = [a, a^2, a + a^2]
        sage: A, w = matrix_representation(K, F1, v)
        sage: w*A.transpose()
        (a, a^2, a^2 + a)
        sage: F2.<x> = FunctionField(F1)
        sage: v = vector(F2, [(x+1)/x, a*x + 1])
        sage: A, w = matrix_representation(K, F2, v)
        sage: w*A.transpose() == v
        True
        sage: R.<y> = F2[]
        sage: F3.<y> = F2.extension(y^2 - x^3 - a)
        sage: v = vector(F3, [y*x, y*a, x])
        sage: A, w = matrix_representation(K, F3, v)
        sage: w*A.transpose() == v
        True

    """
    from sage.arith.functions import lcm
    from sage.modules.free_module_element import vector
    from sage.all import matrix
    assert F.has_coerce_map_from(K), "K must be a subfield of F"
    v = vector(F, [F(v[i]) for i in range(len(v))])
    if F == K:
        return matrix(v).transpose(), vector(K, [K.one()])

    elif is_finite_simple_extension(K, F):
        # F is a finite extension of its base field K
        n = F.degree()
        # the entries of w are the standard basis of F/K
        w = vector(F, [F.gen()**i for i in range(n)])
        A = matrix(K, [vector_for_finite_extension(K, F, v[j]) for j in range(len(v))])
        # test result
        # assert v == w*A.transpose()
        return A, w

    elif is_rational_function_field(K, F):
        # F is the rational function field over K
        x = F.gen()
        n = len(v)
        h = lcm([v[j].denominator() for j in range(n)])
        g_list = [F._ring(v[j]*h) for j in range(n)]
        N = max([g.degree() for g in g_list]) + 1
        w = vector(F, [x**i/h for i in range(N)])
        A = matrix(K, n, N)
        for i in range(n):
            for j in range(N):
                A[i, j] = g_list[i][j]
        # vector_list = []
        # for g in g_list:
        #     g_vector = vector(K, N, [g[i] for i in range(N)])
        #     vector_list.append(g_vector)
        # A = matrix(K, vector_list)
        assert v == w*A.transpose()
        return A, w

    elif is_composite(K, F):
        # F is a finite extension of its base field, which properly contains K
        F0 = intermediate_field(K, F)
        A, w = matrix_representation(F0, F, v)
        m, n = A.dimensions()
        a = vector(F0, m*n)
        for i in range(m):
            for j in range(n):
                a[j + i*n] = A[i, j]
        B, u = matrix_representation(K, F0, a)
        _, r = B.dimensions()
        x = vector(F, r*n)
        C = matrix(K, m, r*n)
        for j in range(n):
            for k in range(r):
                mu = j + n*k
                x[mu] += w[j]*u[k]
                for i in range(m):
                    ell = j + n*i
                    C[i, mu] += B[ell, k]
        # test the result
        assert x*C.transpose() == v
        return C, x
    else:
        raise NotImplementedError()
