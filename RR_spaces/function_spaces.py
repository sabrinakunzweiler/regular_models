r"""
Function spaces
===============

By a *function space* we mean a finite dimensional `K`-subspace `V\subset F`,
where `F/K` is a function field.

The main problem we have to solve is this: given a tuple `(f_1,\ldots,f_n)` of
elements of `F`, find the subspace `R\subset K^n` of linear relations between
the `f_i`.

A related problem is to find a basis of the `K`-subspace of `F` generated by
`(f_1,\ldots,f_n)`.

"""

from sage.all import SageObject

class FunctionSpace(SageObject):
    r""" Return the function space with given generator.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a function field over `K`
    - ``gens`` -- a list of elements of `F`

    OUTPUT:

    the `K`-vector subspace of `F` generated by ``gens``

    """

    def __init__(self, K, F, gens):
        assert K is F.constant_base_field(), "K must be the constant base field of F"
        assert all([f in F for f in gens]), "the generators must lie in F"
        self._constant_base_field = K
        self._function_field = F
        self._gens = gens

    def __repr__(self):
        return "function space inside {}".format(self._function_field)

    def is_in(self, f, coefficients=True):
        r""" Return whether f lies in this function space.

        INPUT:

        - ``f`` -- an element of this function space
        - ``coefficients`` -- a boolean (default=``True``)

        OUTPUT:

        ``True`` if `f` lies in this function space, ``False`` otherwise.
        If ``coefficients`` is true, then we also get the list of coefficients
        presenting `f` as a `K`-linear combination of the original generators
        (or ``None`` if `f` does not lie in our function space).

        """
        F = self._function_field
        assert f in F, "f must lie in the function field F"
        f_list = self._gens + [f]
        n = len(f_list) - 1
        relations = relation_space(F, f_list).basis()
        for i in range(len(relations)):
            relation = relations[i]
            if not relation[n].is_zero():
                # f lies in the function space
                c = relation[n]
                return True, [-a/c for a in relation[:n]]
        return False, None


def basis_of_function_space(F, f_list):
    r""" Return a sublist which is a basis.

    INPUT:

    - ``F`` -- a function field with base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT:

    a basis of the `K`-subspace of `F` generated by ``f_list``; in fact,
    a suitable sublist of ``f_list`` is returned.

    EXAMPLES:

    ::

        sage: from function_spaces import *
        sage: F.<x> = FunctionField(QQ)
        sage: basis_of_function_space(F, [x, 1/x, (x^2+1)/x, (x+1)/x^2])
        [x, 1/x, (x + 1)/x^2]
        sage: R.<y> = F[]
        sage: F1.<y> = F.extension(y^2-x^3-1)
        sage: basis_of_function_space(F1, [x*y, (x/(x^3 + 1))*y, ((x^4 + 2*x)/(x^3 + 1))*y])
        [x*y, (x/(x^3 + 1))*y]

    """
    from sage.matrix.constructor import matrix
    vector_list, _ = vector_representation(F, f_list)
    A = matrix(vector_list)
    indices = A.pivot_rows()
    return [f_list[i] for i in indices]


def relation_space(F, f_list):
    r""" Return the space of relations between a given list of elements of a
    function field.

    INPUT:

    - ``F`` -- a function field with base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT: suppose ``f_list`` is `[f_1,\ldots,f_n]`. Then we return the
    subspace of `K^n` consisting of all linear relations between the `f_i`.

    """
    from sage.matrix.constructor import matrix
    vector_list, _ = vector_representation(F, f_list)
    A = matrix(vector_list)
    return A.kernel()


def vector_representation(F, f_list):
    r""" Return a list of vectors representing the given list of function field
    elements.

    INPUT:

    - ``F`` -- a function field with base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT: a pair (``vector_list``, ``basis``), where ``vector_list`` is a list
    of vectors `v_i\in K^N`

    """
    from sage.arith.functions import lcm
    from sage.modules.free_module_element import vector
    K = F.constant_base_field()
    F0 = F.base_field()
    if F is F0:
        # F is the rational function field over K
        x = F.gen()
        h = lcm([f.denominator() for f in f_list])
        g_list = [(f*h).numerator() for f in f_list]
        N = max([g.degree() for g in g_list]) + 1
        basis = [x**i/h for i in range(N)]
        vector_list = []
        for g in g_list:
            g_vector = vector(K, N, [g[i] for i in range(N)])
            vector_list.append(g_vector)
    else:
        y = F.gen()
        d = F.degree()
        coeff_list = []
        for f in f_list:
            coeff_list += F(f).list()
        vector_list1, basis1 = vector_representation(F0, coeff_list)
        N = len(basis1)
        basis = []
        for j in range(d):
            for i in range(len(basis1)):
                basis.append(basis1[i]*y**j)
        vector_list = []
        for i in range(len(f_list)):
            v = []
            for j in range(d):
                v += vector_list1[i*d + j]
            v = vector(K, N*d, v)
            vector_list.append(v)
    # we check the result
    for i in range(len(f_list)):
        f = f_list[i]
        v = vector_list[i]
        assert sum([v[j]*basis[j] for j in range(len(basis))]) == f, "something is wrong!"
    return vector_list, basis
