r"""
Function spaces
===============

By a *function space* we mean a finite dimensional `K`-subspace `V\subset F`,
where `F/K` is a function field.

The main problem we have to solve is this: given a tuple `(f_1,\ldots,f_n)` of
elements of `F`, find the subspace `R\subset K^n` of linear relations between
the `f_i`.

A related problem is to find a basis of the `K`-subspace of `F` generated by
`(f_1,\ldots,f_n)`.

"""


def basis_of_function_space(F, f_list):
    r""" Return a sublist which is a basis.

    INPUT:

    - ``F`` -- a function field with base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT:

    a basis of the `K`-subspace of `F` generated by ``f_list``; in fact,
    a suitable sublist of ``f_list`` is returned.

    EXAMPLES:

    ::

        sage: from function_spaces import *
        sage: F.<x> = FunctionField(QQ)
        sage: basis_of_function_space(F, [x, 1/x, (x^2+1)/x, (x+1)/x^2])
        [x, 1/x, (x + 1)/x^2]
        sage: R.<y> = F[]
        sage: F1.<y> = F.extension(y^2-x^3-1)
        sage: basis_of_function_space(F1, [x*y, (x/(x^3 + 1))*y, ((x^4 + 2*x)/(x^3 + 1))*y])
        [x*y, (x/(x^3 + 1))*y]

    """
    from sage.matrix.constructor import matrix
    vector_list, _ = vector_representation(F, f_list)
    A = matrix(vector_list)
    indices = A.pivot_rows()
    return [f_list[i] for i in indices]


def relation_space(F, f_list):
    r""" Return the space of relations between a given list of elements of a
    function field.

    INPUT:

    - ``F`` -- a function field with base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT: suppose ``f_list`` is `[f_1,\ldots,f_n]`. Then we return the
    subspace of `K^n` consisting of all linear relations between the `f_i`.

    """
    from sage.matrix.constructor import matrix
    vector_list, _ = vector_representation(F, f_list)
    A = matrix(vector_list)
    return A.kernel()


def vector_representation(F, f_list):
    r""" Return a list of vectors representing the given list of function field
    elements.

    INPUT:

    - ``F`` -- a function field with base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT: a pair (``vector_list``, ``basis``), where ``vector_list`` is a list
    of vectors `v_i\in K^N`

    """
    from sage.arith.functions import lcm
    from sage.modules.free_module_element import vector
    K = F.constant_base_field()
    F0 = F.base_field()
    if F is F0:
        # F is the rational function field over K
        x = F.gen()
        h = lcm([f.denominator() for f in f_list])
        g_list = [(f*h).numerator() for f in f_list]
        N = max([g.degree() for g in g_list]) + 1
        basis = [x**i/h for i in range(N)]
        vector_list = []
        for g in g_list:
            g_vector = vector(K, N, [g[i] for i in range(N)])
            vector_list.append(g_vector)
    else:
        y = F.gen()
        d = F.degree()
        coeff_list = []
        for f in f_list:
            coeff_list += F(f).list()
        vector_list1, basis1 = vector_representation(F0, coeff_list)
        N = len(basis1)
        basis = []
        for j in range(d):
            for i in range(len(basis1)):
                basis.append(basis1[i]*y**j)
        vector_list = []
        for i in range(len(f_list)):
            v = []
            for j in range(d):
                v += vector_list1[i*d + j]
            v = vector(K, N*d, v)
            vector_list.append(v)
    # we check the result
    for i in range(len(f_list)):
        f = f_list[i]
        v = vector_list[i]
        assert sum([v[j]*basis[j] for j in range(len(basis))]) == f, "something is wrong!"
    return vector_list, basis
