r"""
Function spaces
===============

By a *function space* we mean a finite dimensional `K`-subspace `V\subset F`,
where `F/K` is a function field.

The main problem we have to solve is this: given a tuple `(f_1,\ldots,f_n)` of
elements of `F`, find the subspace `R\subset K^n` of linear relations between
the `f_i`.

A related problem is to find a basis of the `K`-subspace of `F` generated by
`(f_1,\ldots,f_n)`.

"""

from sage.all import SageObject


class FunctionSpace(SageObject):
    r""" Return the function space with given generator.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a function field over `K`
    - ``gens`` -- a list of elements of `F`

    OUTPUT:

    the `K`-vector subspace of `F` generated by ``gens``.

    """

    def __init__(self, K, F, gens):
        from sage.matrix.constructor import matrix
        assert K is F.constant_base_field(), "K must be the constant base field of F"
        assert all([f in F for f in gens]), "the generators must lie in F"
        self._constant_base_field = K
        self._function_field = F
        self._gens = gens
        gen_vector_list, _ = vector_representation(K, F, gens)
        A = matrix(K, gen_vector_list)
        indices = A.pivot_rows()
        self._basis = [gens[i] for i in indices]

    def __repr__(self):
        return "function space of dimension {} inside {}".format(self.dimension(),
                                                                 self.function_field())

    def constant_base_field(self):
        return self._constant_base_field

    def function_field(self):
        return self._function_field

    def generators(self):
        r""" Return the list of the original generators of this function space.

        """
        return self._gens

    def basis(self):
        return self._basis

    def dimension(self):
        return len(self.basis())

    def vector(self, f):
        r""" Return vector representations of a list of functions.

        INPUT:

        - ``f`` -- an elelement of the function field `F`

        OUTPUT:

        a vector in `K^d` representing `f` as a linear combination of the
        standard basis of this function space.

        If no such representation exists (i.e.\ if `f` does not lie in this
        function space) then ``None`` is returned.

        """
        from sage.modules.free_module_element import vector
        is_in, v = self.is_in(f, coefficients=True)
        if is_in:
            return vector(self.constant_base_field(), v)
        else:
            return None

    def is_in(self, f, coefficients=False, generators=False):
        r""" Return whether f lies in this function space.

        INPUT:

        - ``f`` -- an element of this function space
        - ``coefficients`` -- a boolean (default=``True``)
        - ``generators`` -- a boolean (default=`False`)

        OUTPUT:

        ``True`` if `f` lies in this function space, ``False`` otherwise.
        If ``coefficients`` is true, then we also get the list of coefficients
        presenting `f` as a `K`-linear combination of the standard basis
        (or ``None`` if `f` does not lie in our function space).
        If ``generators`` is ``True`` then we use the original list of
        generators instead of the standard basis.

        """
        K = self.constant_base_field()
        F = self.function_field()
        assert f in F, "f must lie in the function field F"
        if generators:
            f_list = self._gens + [f]
        else:
            f_list = self._basis + [f]
        n = len(f_list) - 1
        relations = relation_space(K, F, f_list).basis()
        for i in range(len(relations)):
            relation = relations[i]
            if not relation[n].is_zero():
                # f lies in the function space
                c = relation[n]
                if coefficients:
                    return True, [-a/c for a in relation[:n]]
                else:
                    return True
        if coefficients:
            return False, None
        else:
            return False


# ----------------------------------------------------------------------------

#                          auxiliary functions


def basis_of_function_space(K, F, f_list):
    r""" Return a sublist which is a basis.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a function field with constant base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT:

    a basis of the `K`-subspace of `F` generated by ``f_list``; in fact,
    a suitable sublist of ``f_list`` is returned.

    EXAMPLES:

    ::

        sage: from function_spaces import *
        sage: F.<x> = FunctionField(QQ)
        sage: basis_of_function_space(F, [x, 1/x, (x^2+1)/x, (x+1)/x^2])
        [x, 1/x, (x + 1)/x^2]
        sage: R.<y> = F[]
        sage: F1.<y> = F.extension(y^2-x^3-1)
        sage: basis_of_function_space(F1, [x*y, (x/(x^3 + 1))*y, ((x^4 + 2*x)/(x^3 + 1))*y])
        [x*y, (x/(x^3 + 1))*y]

    """
    from sage.matrix.constructor import matrix
    vector_list, _ = vector_representation(K, F, f_list)
    A = matrix(K, vector_list)
    indices = A.pivot_rows()
    return [f_list[i] for i in indices]


def relation_space(K, F, f_list):
    r""" Return the space of relations between a given list of elements of a
    function field.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a function field with constant base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT: suppose ``f_list`` is `[f_1,\ldots,f_n]`. Then we return the
    subspace of `K^n` consisting of all linear relations between the `f_i`.

    """
    from sage.matrix.constructor import matrix
    vector_list, _ = vector_representation(K, F, f_list)
    A = matrix(K, vector_list)
    return A.kernel()


def vector_representation(K, F, f_list):
    r""" Return a list of vectors representing the given list of function field
    elements.

    INPUT:

    - ``K`` -- a field
    - ``F`` -- a function field with constant base field `K`
    - ``f_list`` -- a list of elements of `F`

    OUTPUT: a pair (``vector_list``, ``basis``), where ``vector_list`` is a list
    of vectors `v_i\in K^N` and ``basis`` is a list of elements ``b_j\in F``
    such the following holds:

    - ``basis`` is a basis of a `K`-subspace of `F` containing all elements of ``f_list``

    - the vectors `v_i` in ``vector_list`` are the coordinate vectors of the elements
      of ``f_list`` with respect to the basis ``basis``.

    """
    from sage.arith.functions import lcm
    from sage.modules.free_module_element import vector
    assert K is F.constant_base_field(), "K must be the constant base field of F"
    # this conditions should be relaxed at some point !
    F0 = F.base_field()
    if F is F0:
        # F is the rational function field over K
        x = F.gen()
        h = lcm([f.denominator() for f in f_list])
        g_list = [F._ring(f*h) for f in f_list]
        N = max([g.degree() for g in g_list]) + 1
        basis = [x**i/h for i in range(N)]
        vector_list = []
        for g in g_list:
            g_vector = vector(K, N, [g[i] for i in range(N)])
            vector_list.append(g_vector)
    else:
        y = F.gen()
        d = F.degree()
        coeff_list = []
        for f in f_list:
            coeff_list += F(f).list()
        vector_list1, basis1 = vector_representation(K, F0, coeff_list)
        N = len(basis1)
        basis = []
        for j in range(d):
            for i in range(len(basis1)):
                basis.append(basis1[i]*y**j)
        vector_list = []
        for i in range(len(f_list)):
            v = []
            for j in range(d):
                v += vector_list1[i*d + j]
            v = vector(K, N*d, v)
            vector_list.append(v)
    # we check the result
    for i in range(len(f_list)):
        f = f_list[i]
        v = vector_list[i]
        if sum([v[j]*basis[j] for j in range(len(basis))]) != f:
            print("Error in vector_representation")
            print("f_list = ", f_list)
            print("vector_list = ", vector_list)
            print("basis = ", basis)
            raise ValueError()
    return vector_list, basis
